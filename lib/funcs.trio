// Copyright (C) 2017, National Renewable Energy Laboratory
// All Rights Reserved

---
name:arity
func
doc:
  Given a function name 'fn', return the number of arguments the function accepts.
src:
  (fn) => params(fn).size
---
name:dictToFilter
func
doc:
  Transform the contents of a dict into a string compatible with `parseFilter`. The resulting
  filter string matches records with tags that include all the name-value pairs in dict 'd'.

  Notes
  -----
  
  1. All simple Axon data types are supported except dateTimes, which have no Axon literal.
  2. Dicts that contain reserved keywords as names, such as "return", will not throw an error but
     but may cause downstream functions such as `parseFilter` to fail.
  3. Null values in 'd' will cause `parseFilter` to fail downstream; use the utility function
     `removeNull` as needed to clean the input.
src:
  (d) => do
    // Start filter string
    s: ""
  
    // Create filter string
    d.each() (v, n) => do
      // Add logical operator
      if (s.size > 0) s = s + " and "
  
      // Add name
      s = s + n
  
      // Add value
      if (v != marker()) do
        s = s + "==" + v.toAxonCode
      end
    end
  
    // Return filter string
    s
  end
---
name:exportFunctions
func
doc:
  Exports a grid of functions 'funcs' to a tagged record input/output (TRIO) file 'filename' for
  reuse elsewhere. If missing, the "io/" prefix and ".trio" suffix are added to 'filename'
  automatically.
  
  Examples
  --------
  
    readAll(func).exportFunctions("myFunctions")  >> Writes to `io/myFunctions.trio`
src:
  (funcs, filename) => do
    // Check filename
    if (not(filename.toStr.startsWith("io/"))) filename = "io/" + filename
    if (not(filename.toStr.lower.endsWith(".trio"))) filename = filename + ".trio"
    
    // Write output
    funcs.toGrid
      .map(f => f.remove("id").remove("mod"))
      .sort("name")
      .ioWriteTrio(filename.parseUri)
  end
---
name:importFunctions
func
doc:
  Imports a tagged record input/output (TRIO) file of functions (e.g. exported using
  `exportFunctions`) and commits them to the Folio. If missing, the "io/" prefix and ".trio" suffix
  are added to 'filename' automatically.
  
  Examples
  --------
  
    importFunctions("myFunctions")  >> Reads from `io/myFunctions.trio`
src:
  (filename) => do
    // Check filename
    if (not(filename.toStr.startsWith("io/"))) filename = "io/" + filename
    if (not(filename.toStr.lower.endsWith(".trio"))) filename = filename + ".trio"
    
    // Read and commit functions
    ioReadTrio(filename.parseUri)
      .findAll(rec => rec.has("func"))
      .each() f => commit(diff(null, f, {add}))
  end
---
name:intersect
func
doc:
  Returns the set intersection of two lists or dicts 'a' and 'b'. Behavior for dicts differs by
  'checked':
  
  - If 'checked' is *true*, verifies that keys included in both 'a' and 'b' have matching values,
    and throws an error on mismatch.
  - If 'checked' is *false*, excludes name-value pairs with matching keys but differing values.

  Examples
  --------
  
    intersect([1, 2, 3],[2, 3, 4])        >> [2, 3]
    intersect({a, b}, {a, c})             >> {a}
    intersect({a, b:1}, {a, b:1})         >> {a, b:1}
    intersect({a, b:1}, {a, b:2})         >> error
    intersect({a, b:1}, {a, b:2}, false)  >> {a}
src:
  (a, b, checked:true) => do
    // Lists
    if(a.isList and b.isList) do
      return a.findAll(v => b.contains(v)).unique
    
    // Dicts
    else if(a.isDict and b.isDict) do
      // Common names
      cn: a.names.findAll() n => b.names.contains(n)
      
      // Filter
      a = a.findAll() (v, n) => cn.contains(n)
      
      // Value matching
      if (checked) do
        // Values must match
        a.each() (v, n) => if (b[n] != v) throw "Values do not match for key \"" + n + "\"."
      end else do
        // Discard keys with mismatched values
        a.each() (v, n) => if (b[n] != v) a = a.remove(n)
      end
      
      // Return
      return a
    
    // Other
    else do
      throw "Invalid arguments; need two lists or two dicts."
    end
  end
---
name:isNA
func
doc:
  Returns *true* if 'val' is equal to NA, *false* otherwise.
src:
  (val) => val == na() 
---
name:removeNA
func
doc:
  Removes NA values from list or dict 'x'.
src:
  (x) => x.findAll() v => v != na()
---
name:removeNull
func
doc:
  Removes null values from list or dict 'x'.
src:
  (x) => x.findAll() v => v != null
---
name:removeVal
func
doc:
  Remove any elements from list or dict 'x' that equal 'val'.
src:
  (x, val) => x.findAll() v => v != val
---
name:replace2
func
doc:
  Convenience wrapper for `replace` that also allows processing of URIs or dicts:
  
  - If 'val' is a string, identical to `replace`
  - If 'val' is a URI, it is coerced to string, modified, and re-parsed as a URI
  - If 'val' is a dict or list, all its string and URI elements have the replacement applied 
  
  For dicts and lists, the string replacement is not recursive. (For instance, the replacement will
  not reach inside of dicts nested within lists.)
src:
  (val, from, to) => do
    // Convenience URI replacement function
    replaceUri: (v, f, t) => v.toStr.replace(f, t).parseUri
    
    // String
    if (val.isStr) return val.replace(from, to)
    
    // URI
    if (val.isUri) return val.replaceUri(from, to)
    
    // Dict
    if (val.isDict or val.isList) do
      return val.map() v => do
        if (v.isStr) return v.replace(from, to)
        if (v.isUri) return v.replaceUri(from, to)
        v // Default
      end
    end
  end
---
name:setDiff
func
doc:
  Returns the set difference of two lists or dicts 'a' and 'b': all elements of 'a' that are not in
  'b'.
  
  For dicts, elements for removal are checked by name only (values are ignored, including for
  keys mapped to 'Remove.val').

  Examples
  --------
  
    setDiff([1, 2, 3],[2, 3, 4])  >> [1]
    setDiff({a, b}, {a, c})       >> {b}
    setDiff({a, b:1}, {b:2})      >> {a}
    setDiff({a, b:1}, {-b})       >> {a}
src:
  (a, b) => do
    // Lists
    if(a.isList and b.isList) do
      return a.findAll(v => not(b.contains(v))).unique
    
    // Dicts
    else if(a.isDict and b.isDict) do
      return a.findAll() (v, n) => not(b.has(n))
    
    // Other
    else do
      throw "Invalid arguments; need two lists or two dicts."
    end
  end
---
name:stringToList
func
doc:
  Converts a string of comma-separated values to a list using `eval`. Automatically adds brackets
  '[' ']' if needed.
src:
  (s) => do
    // Handle brackets
    if (not s.startsWith("[")) s = "[" + s
    if (not s.endsWith("]")) s = s + "]"
  
    // Eval
    eval(s)
  end
---
name:union
func
doc:
  Returns the set union of two lists or dicts 'a' and 'b'. Behavior for dicts differs by
  'checked':
  
  - If 'checked' is *true*, verifies that keys included in both 'a' and 'b' have matching values,
    and throws an error on mismatch.
  - If 'checked' is *false*, values from 'a' override values from 'b'. This is similar to
    'merge(b, a)' except that keys not mapped to 'Remove.val' always take precedence.

  Examples
  --------
  
    union([1, 2, 3],[2, 3, 4])        >> [1, 2, 3, 4]
    union({a, b}, {a, c})             >> {a, b, c}
    union({a, b}, {-b, c}, false)     >> {a, b, c}
    union({a, b:1}, {a, b:1})         >> {a, b:1}
    union({a, b:1}, {a, b:2})         >> error
    union({a, b:1}, {a, b:2}, false)  >> {a, b:1}
src:
  (a, b, checked:true) => do
    // Lists
    if(a.isList and b.isList) do
      return a.addAll(b).unique
    
    // Dicts
    else if(a.isDict and b.isDict) do
      // Value matching
      if (checked) do
        b.names.each() n => do
          if (a.has(n) and a[n] != b[n]) throw "Values do not match for key \"" + n + "\"."
        end
      end
      
      // Merge, without dropping values
      return merge(merge(a, b), merge(b, a))
    
    // Other
    else do
      throw "Invalid arguments; need two lists or two dicts."
    end
  end
